"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration)

Date:   Mon Aug 08 14:51:59 2016

Model author: Simon Van Mierlo+Raphael Mannadiar
Model name:   Bouncing_Balls_Python_Version
Model description:
Tkinter frame with bouncing balls in it.
"""

from sccd.runtime.statecharts_core import *
import random, sys

# package "Bouncing_Balls_Python_Version"

class MainApp(RuntimeClassBase):
    def __init__(self, controller):
        RuntimeClassBase.__init__(self, controller)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        MainApp.user_defined_constructor(self)
    
    def user_defined_constructor(self):
        self.nr_of_fields = 0
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, self)
        
        # state /running
        self.states["/running"] = State(1, self)
        
        # state /running/root
        self.states["/running/root"] = ParallelState(2, self)
        
        # state /running/root/cd_behaviour
        self.states["/running/root/cd_behaviour"] = State(3, self)
        
        # state /running/root/cd_behaviour/waiting
        self.states["/running/root/cd_behaviour/waiting"] = State(4, self)
        
        # state /running/root/cd_behaviour/creating
        self.states["/running/root/cd_behaviour/creating"] = State(5, self)
        
        # state /running/root/spawn_windows
        self.states["/running/root/spawn_windows"] = State(6, self)
        
        # state /running/root/spawn_windows/spawning
        self.states["/running/root/spawn_windows/spawning"] = State(7, self)
        self.states["/running/root/spawn_windows/spawning"].setEnter(self._running_root_spawn_windows_spawning_enter)
        self.states["/running/root/spawn_windows/spawning"].setExit(self._running_root_spawn_windows_spawning_exit)
        
        # state /running/stopped
        self.states["/running/stopped"] = State(8, self)
        
        # add children
        self.states[""].addChild(self.states["/running"])
        self.states["/running"].addChild(self.states["/running/root"])
        self.states["/running"].addChild(self.states["/running/stopped"])
        self.states["/running/root"].addChild(self.states["/running/root/cd_behaviour"])
        self.states["/running/root"].addChild(self.states["/running/root/spawn_windows"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/waiting"])
        self.states["/running/root/cd_behaviour"].addChild(self.states["/running/root/cd_behaviour/creating"])
        self.states["/running/root/spawn_windows"].addChild(self.states["/running/root/spawn_windows/spawning"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/running"]
        self.states["/running"].default_state = self.states["/running/root"]
        self.states["/running/root/cd_behaviour"].default_state = self.states["/running/root/cd_behaviour/waiting"]
        self.states["/running/root/spawn_windows"].default_state = self.states["/running/root/spawn_windows/spawning"]
        
        # transition /running/root/cd_behaviour/waiting
        _running_root_cd_behaviour_waiting_0 = Transition(self, self.states["/running/root/cd_behaviour/waiting"], [self.states["/running/root/cd_behaviour/creating"]])
        _running_root_cd_behaviour_waiting_0.setAction(self._running_root_cd_behaviour_waiting_0_exec)
        _running_root_cd_behaviour_waiting_0.setTrigger(Event("create_field", None))
        self.states["/running/root/cd_behaviour/waiting"].addTransition(_running_root_cd_behaviour_waiting_0)
        
        # transition /running/root/cd_behaviour/creating
        _running_root_cd_behaviour_creating_0 = Transition(self, self.states["/running/root/cd_behaviour/creating"], [self.states["/running/root/cd_behaviour/waiting"]])
        _running_root_cd_behaviour_creating_0.setAction(self._running_root_cd_behaviour_creating_0_exec)
        _running_root_cd_behaviour_creating_0.setTrigger(Event("instance_created", None))
        self.states["/running/root/cd_behaviour/creating"].addTransition(_running_root_cd_behaviour_creating_0)
        
        # transition /running/root/spawn_windows/spawning
        _running_root_spawn_windows_spawning_0 = Transition(self, self.states["/running/root/spawn_windows/spawning"], [self.states["/running/root/spawn_windows/spawning"]])
        _running_root_spawn_windows_spawning_0.setAction(self._running_root_spawn_windows_spawning_0_exec)
        _running_root_spawn_windows_spawning_0.setTrigger(Event("_0after"))
        _running_root_spawn_windows_spawning_0.setGuard(self._running_root_spawn_windows_spawning_0_guard)
        self.states["/running/root/spawn_windows/spawning"].addTransition(_running_root_spawn_windows_spawning_0)
    
    def _running_root_spawn_windows_spawning_enter(self):
        self.addTimer(0, (1000 - self.getSimulatedTime() % 1000) / 1000.0)
    
    def _running_root_spawn_windows_spawning_exit(self):
        self.removeTimer(0)
    
    def _running_root_cd_behaviour_waiting_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("create_instance", None, [self, "fields"]))
    
    def _running_root_cd_behaviour_creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _running_root_spawn_windows_spawning_0_exec(self, parameters):
        self.raiseInternalEvent(Event("create_field", None, []))
    
    def _running_root_spawn_windows_spawning_0_guard(self, parameters):
        return self.nr_of_fields < 10
    
    def initializeStatechart(self):
        # enter default state
        self.default_targets = self.states["/running"].getEffectiveTargetStates()
        RuntimeClassBase.initializeStatechart(self)

class Field(RuntimeClassBase):
    def __init__(self, controller):
        RuntimeClassBase.__init__(self, controller)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        Field.user_defined_constructor(self)
    
    def user_defined_constructor(self):
        pass
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, self)
        
        # state /root
        self.states["/root"] = State(1, self)
        
        # state /root/running
        self.states["/root/running"] = ParallelState(2, self)
        
        # state /root/running/main_behaviour
        self.states["/root/running/main_behaviour"] = State(3, self)
        
        # state /root/running/main_behaviour/running
        self.states["/root/running/main_behaviour/running"] = State(4, self)
        
        # state /root/running/main_behaviour/creating
        self.states["/root/running/main_behaviour/creating"] = State(5, self)
        
        # state /root/running/spawn_balls
        self.states["/root/running/spawn_balls"] = State(6, self)
        
        # state /root/running/spawn_balls/spawning
        self.states["/root/running/spawn_balls/spawning"] = State(7, self)
        self.states["/root/running/spawn_balls/spawning"].setEnter(self._root_running_spawn_balls_spawning_enter)
        self.states["/root/running/spawn_balls/spawning"].setExit(self._root_running_spawn_balls_spawning_exit)
        
        # state /root/deleting
        self.states["/root/deleting"] = State(8, self)
        
        # state /root/deleted
        self.states["/root/deleted"] = State(9, self)
        
        # add children
        self.states[""].addChild(self.states["/root"])
        self.states["/root"].addChild(self.states["/root/running"])
        self.states["/root"].addChild(self.states["/root/deleting"])
        self.states["/root"].addChild(self.states["/root/deleted"])
        self.states["/root/running"].addChild(self.states["/root/running/main_behaviour"])
        self.states["/root/running"].addChild(self.states["/root/running/spawn_balls"])
        self.states["/root/running/main_behaviour"].addChild(self.states["/root/running/main_behaviour/running"])
        self.states["/root/running/main_behaviour"].addChild(self.states["/root/running/main_behaviour/creating"])
        self.states["/root/running/spawn_balls"].addChild(self.states["/root/running/spawn_balls/spawning"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/root"]
        self.states["/root"].default_state = self.states["/root/running"]
        self.states["/root/running/main_behaviour"].default_state = self.states["/root/running/main_behaviour/running"]
        self.states["/root/running/spawn_balls"].default_state = self.states["/root/running/spawn_balls/spawning"]
        
        # transition /root/running/main_behaviour/running
        _root_running_main_behaviour_running_0 = Transition(self, self.states["/root/running/main_behaviour/running"], [self.states["/root/running/main_behaviour/creating"]])
        _root_running_main_behaviour_running_0.setAction(self._root_running_main_behaviour_running_0_exec)
        _root_running_main_behaviour_running_0.setTrigger(Event("spawn_ball", None))
        self.states["/root/running/main_behaviour/running"].addTransition(_root_running_main_behaviour_running_0)
        
        # transition /root/running/main_behaviour/creating
        _root_running_main_behaviour_creating_0 = Transition(self, self.states["/root/running/main_behaviour/creating"], [self.states["/root/running/main_behaviour/running"]])
        _root_running_main_behaviour_creating_0.setAction(self._root_running_main_behaviour_creating_0_exec)
        _root_running_main_behaviour_creating_0.setTrigger(Event("instance_created", None))
        self.states["/root/running/main_behaviour/creating"].addTransition(_root_running_main_behaviour_creating_0)
        
        # transition /root/running/spawn_balls/spawning
        _root_running_spawn_balls_spawning_0 = Transition(self, self.states["/root/running/spawn_balls/spawning"], [self.states["/root/running/spawn_balls/spawning"]])
        _root_running_spawn_balls_spawning_0.setAction(self._root_running_spawn_balls_spawning_0_exec)
        _root_running_spawn_balls_spawning_0.setTrigger(Event("_0after"))
        self.states["/root/running/spawn_balls/spawning"].addTransition(_root_running_spawn_balls_spawning_0)
        
        # transition /root/deleting
        _root_deleting_0 = Transition(self, self.states["/root/deleting"], [self.states["/root/deleted"]])
        _root_deleting_0.setAction(self._root_deleting_0_exec)
        _root_deleting_0.setTrigger(None)
        self.states["/root/deleting"].addTransition(_root_deleting_0)
    
    def _root_running_spawn_balls_spawning_enter(self):
        self.addTimer(0, (50 - self.getSimulatedTime() % 50) / 1000.0)
    
    def _root_running_spawn_balls_spawning_exit(self):
        self.removeTimer(0)
    
    def _root_running_main_behaviour_running_0_exec(self, parameters):
        x = parameters[0]
        y = parameters[1]
        self.big_step.outputEventOM(Event("create_instance", None, [self, "balls", "Ball", x, y]))
    
    def _root_running_main_behaviour_creating_0_exec(self, parameters):
        association_name = parameters[0]
        self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
    
    def _root_running_spawn_balls_spawning_0_exec(self, parameters):
        self.raiseInternalEvent(Event("spawn_ball", None, [150, 150]))
    
    def _root_deleting_0_exec(self, parameters):
        self.big_step.outputEventOM(Event("narrow_cast", None, [self, 'parent', Event("delete_field", None, [self.association_name])]))
    
    def initializeStatechart(self):
        # enter default state
        states = self.states["/root"].getEffectiveTargetStates()
        self.updateConfiguration(states)
        for state in states:
            if state.enter:
                state.enter()

class Ball(RuntimeClassBase):
    def __init__(self, controller, x, y):
        RuntimeClassBase.__init__(self, controller)
        
        self.semantics.big_step_maximality = StatechartSemantics.TakeMany
        self.semantics.internal_event_lifeline = StatechartSemantics.Queue
        self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
        self.semantics.priority = StatechartSemantics.SourceParent
        self.semantics.concurrency = StatechartSemantics.Single
        
        # build Statechart structure
        self.build_statechart_structure()
        
        # call user defined constructor
        Ball.user_defined_constructor(self, x, y)
    
    def user_defined_constructor(self, x, y):
        self.r = 20.0;
        self.vel = {'x': random.uniform(-5.0, 5.0), 'y': random.uniform(-5.0, 5.0)};
        self.mouse_pos = {};
        self.smooth = 0.4; # value between 0 and 1
        self.pos = {'x': x, 'y': y}
    
    def user_defined_destructor(self):
        pass
    
    
    # builds Statechart structure
    def build_statechart_structure(self):
        
        # state <root>
        self.states[""] = State(0, self)
        
        # state /main_behaviour
        self.states["/main_behaviour"] = State(1, self)
        
        # state /main_behaviour/bouncing
        self.states["/main_behaviour/bouncing"] = State(2, self)
        self.states["/main_behaviour/bouncing"].setEnter(self._main_behaviour_bouncing_enter)
        self.states["/main_behaviour/bouncing"].setExit(self._main_behaviour_bouncing_exit)
        
        # add children
        self.states[""].addChild(self.states["/main_behaviour"])
        self.states["/main_behaviour"].addChild(self.states["/main_behaviour/bouncing"])
        self.states[""].fixTree()
        self.states[""].default_state = self.states["/main_behaviour"]
        self.states["/main_behaviour"].default_state = self.states["/main_behaviour/bouncing"]
        
        # transition /main_behaviour/bouncing
        _main_behaviour_bouncing_0 = Transition(self, self.states["/main_behaviour/bouncing"], [self.states["/main_behaviour/bouncing"]])
        _main_behaviour_bouncing_0.setAction(self._main_behaviour_bouncing_0_exec)
        _main_behaviour_bouncing_0.setTrigger(Event("_0after"))
        self.states["/main_behaviour/bouncing"].addTransition(_main_behaviour_bouncing_0)
    
    def _main_behaviour_bouncing_enter(self):
        self.addTimer(0, (1000 - self.getSimulatedTime() % 1000) / 1000.0)
    
    def _main_behaviour_bouncing_exit(self):
        self.removeTimer(0)
    
    def _main_behaviour_bouncing_0_exec(self, parameters):
        self.pos
        if self.pos['x'] - self.r <= 0 or self.pos['x'] + self.r >= 800 :
            self.vel['x'] = -self.vel['x'];
        if self.pos['y'] - self.r <= 0 or self.pos['y'] + self.r >= 600 :
            self.vel['y'] = -self.vel['y'];
        self.pos['x'] += self.vel['x']
        self.pos['y'] += self.vel['y']
    
    def initializeStatechart(self):
        # enter default state
        states = self.states["/main_behaviour"].getEffectiveTargetStates()
        self.updateConfiguration(states)
        for state in states:
            if state.enter:
                state.enter()

class ObjectManager(ObjectManagerBase):
    def __init__(self, controller):
        ObjectManagerBase.__init__(self, controller)
    
    def instantiate(self, class_name, construct_params):
        if class_name == "MainApp":
            instance = MainApp(self.controller)
            instance.associations = {}
            instance.associations["fields"] = Association("Field", 0, -1)
        elif class_name == "Field":
            instance = Field(self.controller)
            instance.associations = {}
            instance.associations["balls"] = Association("Ball", 0, -1)
            instance.associations["parent"] = Association("MainApp", 1, 1)
        elif class_name == "Ball":
            instance = Ball(self.controller, construct_params[0], construct_params[1])
            instance.associations = {}
            instance.associations["parent"] = Association("Field", 1, 1)
        else:
            raise Exception("Cannot instantiate class " + class_name)
        return instance

class Controller(ThreadsControllerBase):
    def __init__(self, keep_running = None, behind_schedule_callback = None):
        if keep_running == None: keep_running = True
        if behind_schedule_callback == None: behind_schedule_callback = None
        ThreadsControllerBase.__init__(self, ObjectManager(self), keep_running, behind_schedule_callback)
        self.object_manager.createInstance("MainApp", [])