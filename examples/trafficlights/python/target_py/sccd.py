"""
Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration)

Date:   Thu Jul 28 15:43:05 2016

Model author: Raphael Mannadiar
Model name:   Traffic_Light_Python_Version

"""

from python_runtime.statecharts_core import *
from python_runtime.libs.ui import ui

# package "Traffic_Light_Python_Version"

class MainApp(RuntimeClassBase):
	def __init__(self, controller):
		RuntimeClassBase.__init__(self, controller)
		
		self.semantics.big_step_maximality = StatechartSemantics.TakeMany
		self.semantics.internal_event_lifeline = StatechartSemantics.Queue
		self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
		self.semantics.priority = StatechartSemantics.SourceParent
		self.semantics.concurrency = StatechartSemantics.Single
		
		# build Statechart structure
		self.build_statechart_structure()
		
		# call user defined constructor
		MainApp.user_defined_constructor(self)
	
	def user_defined_constructor(self):
		self.canvas   = ui.append_canvas(ui.window,100,310,{'background':'#eee'});
		police_button = ui.append_button(ui.window, 'Police interrupt');
		quit_button   = ui.append_button(ui.window, 'Quit');
		ui.bind_event(police_button.element, ui.EVENTS.MOUSE_CLICK, self.controller, 'police_interrupt_clicked');
		ui.bind_event(quit_button.element,      ui.EVENTS.MOUSE_CLICK, self.controller, 'quit_clicked');
	
	def user_defined_destructor(self):
		pass
	
	
	# builds Statechart structure
	def build_statechart_structure(self):
		
		# state /initializing
		self.states["/initializing"] = State(0, self)
		
		# state /creating
		self.states["/creating"] = State(1, self)
		
		# state /initialized
		self.states["/initialized"] = State(2, self)
		
		# state <root>
		self.states[""] = State(3, self)
		
		# add children
		self.states[""].children.add(self.states["/initializing"])
		self.states[""].children.add(self.states["/creating"])
		self.states[""].children.add(self.states["/initialized"])
		self.states[""].fixTree()
		self.states[""].default = self.states["/initializing"]
		
		# transition /initializing
		_initializing_0 = Transition(self, self.states["/initializing"], self.states["/creating"])
		_initializing_0.executables["action"] = self._initializing_0_exec
		self.states["/initializing"].transitions.add(_initializing_0)
		
		# transition /creating
		_creating_0 = Transition(self, self.states["/creating"], self.states["/initialized"])
		_creating_0.executables["action"] = self._creating_0_exec
		_creating_0.trigger = Event("instance_created", None)
		self.states["/creating"].transitions.add(_creating_0)
	
	def _initializing_0_exec(self, parameters):
		self.big_step.outputEventOM(Event("create_instance", None, [self, "trafficlight", "TrafficLight", self.canvas]))
	
	def _creating_0_exec(self, parameters):
		association_name = parameters[0]
		self.big_step.outputEventOM(Event("start_instance", None, [self, association_name]))
		self.big_step.outputEventOM(Event("narrow_cast", None, [self, association_name, Event("set_association_name", None, [association_name])]))
	
	# generate transition candidates for current small step
	def generateCandidates(self):
		enabledEvents = self.getEnabledEvents()
		enabledTransitions = OrderedSet()
		for s in self.configuration:
			if not (s in self.combo_step.changed):
				for t in s.transitions:
					if t.isEnabled(enabledEvents):
						enabledTransitions.add(t)
		return enabledTransitions
	
	def initializeStatechart(self):
		# enter default state
		states = self.states["/initializing"].getEffectiveTargetStates()
		self.configuration.update(states)
		for state in states:
			if state.executables["enter"]:
				state.executables["enter"]()

class TrafficLight(RuntimeClassBase):
	def __init__(self, controller, canvas):
		RuntimeClassBase.__init__(self, controller)
		
		self.semantics.big_step_maximality = StatechartSemantics.TakeMany
		self.semantics.internal_event_lifeline = StatechartSemantics.Queue
		self.semantics.input_event_lifeline = StatechartSemantics.FirstComboStep
		self.semantics.priority = StatechartSemantics.SourceParent
		self.semantics.concurrency = StatechartSemantics.Single
		
		# build Statechart structure
		self.build_statechart_structure()
		
		# call user defined constructor
		TrafficLight.user_defined_constructor(self, canvas)
	
	def user_defined_constructor(self, canvas):
		size        = 100;
		offset      = size+5;
		self.RED    = 0;
		self.YELLOW = 1;
		self.GREEN  = 2;
		self.colors = ['#f00','#ff0','#0f0']
		self.lights = [
		    canvas.add_rectangle(size/2, size/2, size, size, {'fill':'#000'}),
		    canvas.add_rectangle(size/2, size/2+offset,     size, size, {'fill':'#000'}),
		    canvas.add_rectangle(size/2, size/2+2*offset, size, size, {'fill':'#000'})];
		self.my_after = 1
	
	def user_defined_destructor(self):
		pass
	
	
	# user defined method
	def clear(self):
		self.lights[self.RED].set_color('#000');
		self.lights[self.YELLOW].set_color('#000');
		self.lights[self.GREEN].set_color('#000');
	
	
	# user defined method
	def setGreen(self):
		self.clear();
		self.lights[self.GREEN].set_color(self.colors[self.GREEN]);
	
	
	# user defined method
	def setYellow(self):
		self.clear();
		self.lights[self.YELLOW].set_color(self.colors[self.YELLOW]);
	
	
	# user defined method
	def setRed(self):
		self.clear();
		self.lights[self.RED].set_color(self.colors[self.RED]);
	
	
	# builds Statechart structure
	def build_statechart_structure(self):
		
		# state /on/normal/red
		self.states["/on/normal/red"] = State(0, self)
		self.states["/on/normal/red"].executables["enter"] = self._on_normal_red_enter
		self.states["/on/normal/red"].executables["exit"] = self._on_normal_red_exit
		
		# state /on/normal/green
		self.states["/on/normal/green"] = State(1, self)
		self.states["/on/normal/green"].executables["enter"] = self._on_normal_green_enter
		self.states["/on/normal/green"].executables["exit"] = self._on_normal_green_exit
		
		# state /on/normal/yellow
		self.states["/on/normal/yellow"] = State(2, self)
		self.states["/on/normal/yellow"].executables["enter"] = self._on_normal_yellow_enter
		self.states["/on/normal/yellow"].executables["exit"] = self._on_normal_yellow_exit
		
		# state /on/interrupted/yellow
		self.states["/on/interrupted/yellow"] = State(3, self)
		self.states["/on/interrupted/yellow"].executables["enter"] = self._on_interrupted_yellow_enter
		self.states["/on/interrupted/yellow"].executables["exit"] = self._on_interrupted_yellow_exit
		
		# state /on/interrupted/black
		self.states["/on/interrupted/black"] = State(4, self)
		self.states["/on/interrupted/black"].executables["enter"] = self._on_interrupted_black_enter
		self.states["/on/interrupted/black"].executables["exit"] = self._on_interrupted_black_exit
		
		# state /off
		self.states["/off"] = State(5, self)
		self.states["/off"].executables["enter"] = self._off_enter
		
		# state <root>
		self.states[""] = State(6, self)
		
		# state /on
		self.states["/on"] = State(7, self)
		
		# state /on/normal
		self.states["/on/normal"] = State(8, self)
		
		# state /on/interrupted
		self.states["/on/interrupted"] = State(9, self)
		
		# state /on/normal/history
		self.states["/on/normal/history"] = ShallowHistoryState(10, self)
		
		# add children
		self.states[""].children.add(self.states["/on"])
		self.states[""].children.add(self.states["/off"])
		self.states["/on"].children.add(self.states["/on/normal"])
		self.states["/on"].children.add(self.states["/on/interrupted"])
		self.states["/on/normal"].children.add(self.states["/on/normal/red"])
		self.states["/on/normal"].children.add(self.states["/on/normal/green"])
		self.states["/on/normal"].children.add(self.states["/on/normal/yellow"])
		self.states["/on/normal"].children.add(self.states["/on/normal/history"])
		self.states["/on/interrupted"].children.add(self.states["/on/interrupted/yellow"])
		self.states["/on/interrupted"].children.add(self.states["/on/interrupted/black"])
		self.states[""].fixTree()
		self.states[""].default = self.states["/on"]
		self.states["/on"].default = self.states["/on/normal"]
		self.states["/on/normal"].default = self.states["/on/normal/red"]
		self.states["/on/interrupted"].default = self.states["/on/interrupted/yellow"]
		
		# transition /on/normal/red
		_on_normal_red_0 = Transition(self, self.states["/on/normal/red"], self.states["/on/normal/green"])
		_on_normal_red_0.trigger = Event("_0after")
		self.states["/on/normal/red"].transitions.add(_on_normal_red_0)
		
		# transition /on/normal/green
		_on_normal_green_0 = Transition(self, self.states["/on/normal/green"], self.states["/on/normal/yellow"])
		_on_normal_green_0.trigger = Event("_1after")
		self.states["/on/normal/green"].transitions.add(_on_normal_green_0)
		
		# transition /on/normal/yellow
		_on_normal_yellow_0 = Transition(self, self.states["/on/normal/yellow"], self.states["/on/normal/red"])
		_on_normal_yellow_0.trigger = Event("_2after")
		self.states["/on/normal/yellow"].transitions.add(_on_normal_yellow_0)
		
		# transition /on/interrupted/yellow
		_on_interrupted_yellow_0 = Transition(self, self.states["/on/interrupted/yellow"], self.states["/on/interrupted/black"])
		_on_interrupted_yellow_0.trigger = Event("_3after")
		self.states["/on/interrupted/yellow"].transitions.add(_on_interrupted_yellow_0)
		
		# transition /on/interrupted/black
		_on_interrupted_black_0 = Transition(self, self.states["/on/interrupted/black"], self.states["/on/interrupted/yellow"])
		_on_interrupted_black_0.trigger = Event("_4after")
		self.states["/on/interrupted/black"].transitions.add(_on_interrupted_black_0)
		
		# transition /on
		_on_0 = Transition(self, self.states["/on"], self.states["/off"])
		_on_0.trigger = Event("quit_clicked", "ui")
		self.states["/on"].transitions.add(_on_0)
		
		# transition /on/normal
		_on_normal_0 = Transition(self, self.states["/on/normal"], self.states["/on/interrupted"])
		_on_normal_0.trigger = Event("police_interrupt_clicked", "ui")
		self.states["/on/normal"].transitions.add(_on_normal_0)
		
		# transition /on/interrupted
		_on_interrupted_0 = Transition(self, self.states["/on/interrupted"], self.states["/on/normal/history"])
		_on_interrupted_0.trigger = Event("police_interrupt_clicked", "ui")
		self.states["/on/interrupted"].transitions.add(_on_interrupted_0)
	
	def _on_normal_red_enter(self):
		self.addTimer(0, 3)
		self.setRed();
	
	def _on_normal_red_exit(self):
		self.removeTimer(0)
	
	def _on_normal_green_enter(self):
		self.addTimer(1, 2)
		self.setGreen();
	
	def _on_normal_green_exit(self):
		self.removeTimer(1)
	
	def _on_normal_yellow_enter(self):
		self.addTimer(2, self.my_after)
		self.setYellow();
	
	def _on_normal_yellow_exit(self):
		self.removeTimer(2)
	
	def _on_interrupted_yellow_enter(self):
		self.addTimer(3, .5)
		self.setYellow();
	
	def _on_interrupted_yellow_exit(self):
		self.removeTimer(3)
	
	def _on_interrupted_black_enter(self):
		self.addTimer(4, .5)
		self.clear();
	
	def _on_interrupted_black_exit(self):
		self.removeTimer(4)
	
	def _off_enter(self):
		self.clear();
	
	# generate transition candidates for current small step
	def generateCandidates(self):
		enabledEvents = self.getEnabledEvents()
		enabledTransitions = OrderedSet()
		for s in self.configuration:
			if not (s in self.combo_step.changed):
				for t in s.transitions:
					if t.isEnabled(enabledEvents):
						enabledTransitions.add(t)
		return enabledTransitions
	
	def initializeStatechart(self):
		# enter default state
		states = self.states["/on"].getEffectiveTargetStates()
		self.configuration.update(states)
		for state in states:
			if state.executables["enter"]:
				state.executables["enter"]()

class ObjectManager(ObjectManagerBase):
	def __init__(self, controller):
		ObjectManagerBase.__init__(self, controller)
	
	def instantiate(self, class_name, construct_params):
		if class_name == "MainApp":
			instance = MainApp(self.controller)
			instance.associations = {}
			instance.associations["trafficlight"] = Association("TrafficLight", 0, -1)
		elif class_name == "TrafficLight":
			instance = TrafficLight(self.controller, construct_params[0])
			instance.associations = {}
		return instance

class Controller(EventLoopControllerBase):
	def __init__(self, event_loop_callbacks, finished_callback = None):
		if finished_callback == None: finished_callback = None
		EventLoopControllerBase.__init__(self, ObjectManager(self), event_loop_callbacks, finished_callback)
		self.addInputPort("ui")
		self.object_manager.createInstance("MainApp", [])