
===============
Code generation
===============


Roadmap
=======

  (DONE) Milestone 1: Initial compilation to Rust
  
    - (DONE) entering and exiting states correctly
    - (DONE) incoming event triggers the right transition
    - (DONE) a port of the Controller class to Rust
    - (DONE) one implemented action: raise output event

    - (DONE) fixed semantics (YAKINDU-like)
        - "Take One" big step maximality
        - parent-first 

    - (DONE) goal: subset of SCCD tests passes:
        semantics/big_step_maximality/test_flat_takeone.xml
        semantics/big_step_maximality/test_ortho_takeone.xml
        semantics/priority/test_source_parent.xml
        semantics/priority/test_explicit_flat.xml
        semantics/priority/test_explicit_ortho.xml

    - no history
    - no action language
      - guards evals and action stmts are just logged to console
      - guards always true, actions no effect
    - no event parameters


  Milestone 2: Minimal support for semantic variability:

    - Priority: Child-first
    - Big-Step Maximality: Take Many

    - goal: following tests should pass:
        semantics/priority/test_source_child.xml
        semantics/big_step_maximality/test_flat_takemany.xml
        semantics/big_step_maximality/test_ortho_takemany.xml

Implementation
==============

Data types
----------

- state machine's state
  - [M1] current state(s)
      nested structure of
        - tagged unions (OR-states)
        - structs (AND-states)
  - history values
  - timer IDs

Operations
----------

  - hierarchical operations
    - [M1] entering a state's default state
    - entering a state's (deep/shallow) history
    
  - "flat" operations
    - [M1] firing a transition
      - [M1] exit states
          + save history values
          + canceling timers
          + exit actions
      - transition's actions
      - [M1] enter states
          + enter actions
          + reading history values
          + starting timers

  - [M1] select and execute transition given an event
